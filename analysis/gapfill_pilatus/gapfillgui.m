function gapfillgui
% ***********************************************
% Copyright (c) 2020 UChicago Argonne, LLC
% See LICENSE file.
% ***********************************************
%
% GAPFILL Fill the camear gaps and bad pixels using images taken at 
%   different camera offset positions.

%   Zhang Jiang and Joe Strzalka @8ID/APS/ANL
%   $Revision: 1.0 $  $Date: 2011/03/01 $
%   $Revision: 1.1$  $Date: 2011/07/23 $ Automatical loading of parameter
%       files. (ZJ)
%   $Revision: 1.2$  $Date: 2013/02/03 $ Keep masked region negative values
%       by masking ff
%   $Revision: 1.3$  $Date: 2014/01/29 $ Use single for export data format;
%       fix the file extenstion problem for automatic filling when
%       exporting; with base image at up positition, use vertical offset
%       -23.
%   $Revision: 1.4$  $Date: 2015/12/01 $ Fix bugs for Matlab 2015b upgrade.

hFigGapFill = findall(0,'Tag','gapfill_fig');
if ~isempty(hFigGapFill)
    figure(hFigGapFill);
    return;
end

%% initialize udata field
[guipath,~,~] = fileparts(which('gixsgui.m'));
udata.path = '';
udata.fffile = fullfile(guipath,'pilatus_1mf','flatfield','FF_p1m0108_E11p9_T9p9_vrf_m0p3_20111130.tif');
udata.ff = [];
udata.gapmaskfile = fullfile(guipath,'pilatus_1mf','gapfill','gapmask_extra5row.tif');
udata.gapmask = [];
udata.badpixmaskfile = fullfile(guipath,'pilatus_1mf','gapfill','pilatus1mf_badpix_mask_20160302.tif');
udata.badpixmask = [];
udata.imbasefile = '';
udata.imbasedata = [];
udata.imfile1 = '';
udata.imdata1 = [];
udata.pos1 = [0 -23];
udata.imfile2 = '';
udata.imdata2 = [];
udata.pos2 = [20 0];
udata.imfile3 = '';
udata.imdata3 = [];
udata.pos3 = [20 -23];
udata.imfdata = [];

%% figure layout
screenSize = get(0,'screensize');
figSize = [480,680];
figPos = [(screenSize(3)-figSize(1))/2, (screenSize(4)-figSize(2))/2, figSize];
hFigGapFill = figure(...
    'DockControls','off',...
    'Resize','off',...
    'position',figPos,...
    'PaperOrient','portrait',...
    'PaperPositionMode','auto',...
    'IntegerHandle','off',...
    'NumberTitle','off',...
    'MenuBar','none',...
    'HandleVisibility','callback',...
    'Toolbar','none',...
    'Name','Gap Fill - 1.0 (8ID/APS/ANL)',...
    'Tag','gapfill_fig','UserData',udata);
backgroundcolor = get(hFigGapFill,'color');
% flat field
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String','Flat Field - Load flat field file (TIF/TIFF format). Correction is optional. ',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-25,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Edit',...
    'Units','pixel',...
    'backgroundcolor','w',...
    'String',udata.fffile,...
    'HorizontalAlignment','left',...
    'Enable','on',...
    'Position',[20,figSize(2)-75,figSize(1)-25,20],...
    'Tag','gapfill_EditFF',...
    'callback',@gapfill_EditFFFcn);
gapfill_EditFFFcn;
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Load ...',...
    'unit','pixel',...
    'Position',[20,figSize(2)-50,100,20],...
    'Tag','gapfill_PushbuttonLoadFF',...
    'callback',{@loaddlg,findall(hFigGapFill,'tag','gapfill_EditFF'),'Load Flat Field File',[],udata.fffile});
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Show',...
    'unit','pixel',...
    'Position',[125,figSize(2)-50,100,20],...
    'Tag','gapfill_PushbuttonShowFF',...
    'callback',{@show,'ff',1,'Gap Fill - Flat Field'});
% Gap mask
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String','Gap Mask - Load gap mask file (TIF/TIFF format).',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-100,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Edit',...
    'Units','pixel',...
    'backgroundcolor','w',...
    'Enable','on',...
    'String',udata.gapmaskfile,...
    'HorizontalAlignment','left',...
    'Position',[20,figSize(2)-150,figSize(1)-25,20],...
    'Tag','gapfill_EditGapMask',...
    'callback',@gapfill_EditGapMaskFcn);
gapfill_EditGapMaskFcn;
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Load ...',...
    'unit','pixel',...
    'Position',[20,figSize(2)-125,100,20],...
    'Tag','gapfill_PushbuttonLoadGapMask',...
    'callback',{@loaddlg,findall(hFigGapFill,'tag','gapfill_EditGapMask'),'Load Gap Mask File',[],udata.gapmaskfile});
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Show',...
    'unit','pixel',...
    'Position',[125,figSize(2)-125,100,20],...
    'Tag','gapfill_PushbuttonShowGapMask',...
    'callback',{@show,'gapmask',1,'Gap Fill - Gap Mask'});
% Bad pixel mask
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String','Bad Pixel Mask - Load bad pixel mask file (TIF/TIFF format). ',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-175,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Edit',...
    'Units','pixel',...
    'backgroundcolor','w',...
    'Enable','on',...
    'String',udata.badpixmaskfile,...
    'HorizontalAlignment','left',...
    'Position',[20,figSize(2)-225,figSize(1)-25,20],...
    'Tag','gapfill_EditBadPixelMask',...
    'callback',@gapfill_EditBadPixelMaskFcn);
gapfill_EditBadPixelMaskFcn;
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Load ...',...
    'unit','pixel',...
    'Position',[20,figSize(2)-200,100,20],...
    'Tag','gapfill_PushbuttonLoadBadPixelMask',...
    'callback',{@loaddlg,findall(hFigGapFill,'tag','gapfill_EditBadPixelMask'),'Load Bad Pixel Mask File',[],udata.badpixmaskfile});
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Show',...
    'unit','pixel',...
    'Position',[125,figSize(2)-200,100,20],...
    'Tag','gapfill_PushbuttonShowBadPixelMask',...
    'callback',{@show,'badpixmask',1,'Gap Fill - Bad Pixel Mask'});
% base image;
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String','Base Image - Load base image (upper position) (TIF/TIFF or CBF format only). ',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-250,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Edit',...
    'Units','pixel',...
    'backgroundcolor','w',...
    'Enable','on',...
    'String','',...
    'HorizontalAlignment','left',...
    'Position',[20,figSize(2)-300,figSize(1)-25,20],...
    'Tag','gapfill_EditBase',...
    'callback',@gapfill_EditBaseFcn);
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Load ...',...
    'unit','pixel',...
    'Position',[20,figSize(2)-275,100,20],...
    'Tag','gapfill_PushbuttonLoadBase',...
    'callback',{@loaddlg,findall(hFigGapFill,'tag','gapfill_EditBase'),'Load Base Image (upper position)',[],udata.path});
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Show',...
    'unit','pixel',...
    'Position',[125,figSize(2)-275,100,20],...
    'Tag','gapfill_PushbuttonShowBase',...
    'callback',{@show,'imbasedata',1,'Gap Fill - Base Image'});
% three more images
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String',['Vertical Offset Image - Specify position (in pixels) with respect to the base image.'],...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-325,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String',['Horizontal Offset Image - Specify position (in pixels) with respect to the base image.'],...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-325-75,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String',['Arbitrary Offset Image - Specify position (in pixels) with respect to the base image.'],...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-325-150,figSize(1)-10,15]);
for ii=1:3
    uicontrol('Parent',hFigGapFill,...
        'style','Edit',...
        'Units','pixel',...
        'backgroundcolor','w',...
        'Enable','on',...
        'String','',...
        'HorizontalAlignment','left',...
        'Position',[20,figSize(2)-375-25*3*(ii-1),figSize(1)-25,20],...
        'Tag',['gapfill_EditImage',num2str(ii)],...
        'callback',@gapfill_EditImageFcn,...
        'UserData',ii);    
    uicontrol('Parent',hFigGapFill,...
        'style','pushbutton',...
        'String','Load ...',...
        'unit','pixel',...
        'Position',[20,figSize(2)-350-25*3*(ii-1),100,20],...
        'Tag',['gapfill_PushbuttonLoadImage',num2str(ii)],...
        'callback',{@loaddlg,findall(hFigGapFill,'tag',['gapfill_EditImage',num2str(ii)]),['Load Image #',num2str(ii)],ii,udata.path});
    uicontrol('Parent',hFigGapFill,...
        'style','pushbutton',...
        'String','Show',...
        'unit','pixel',...
        'Position',[125,figSize(2)-350-25*3*(ii-1),100,20],...
        'Tag',['gapfill_PushbuttonShowImage',num2str(ii)],...
        'callback',{@show,['imdata',num2str(ii)],1,['Gap Fill - Image #',num2str(ii)]});
    uicontrol('Parent',hFigGapFill,...
        'style','Text',...
        'Units','pixel',...
        'backgroundcolor',backgroundcolor,...
        'String','X ',...
        'HorizontalAlignment','right',...
        'Position',[230,figSize(2)-350-25*3*(ii-1),20,15]);   
    uicontrol('Parent',hFigGapFill,...
        'style','Edit',...
        'String', udata.(['pos',num2str(ii)])(1),...
        'unit','pixel',...
        'background','w',...
        'Position',[255,figSize(2)-350-25*3*(ii-1),50,20],...
        'Tag',['gapfill_EditPosX',num2str(ii)],...
        'callback',{@getpos,ii});
    uicontrol('Parent',hFigGapFill,...
        'style','Text',...
        'Units','pixel',...
        'backgroundcolor',backgroundcolor,...
        'String','Y ',...
        'HorizontalAlignment','right',...
        'Position',[310,figSize(2)-350-25*3*(ii-1),20,15]);   
    uicontrol('Parent',hFigGapFill,...
        'style','Edit',...
        'String',udata.(['pos',num2str(ii)])(2),...
        'unit','pixel',...
        'background','w',...
        'Position',[335,figSize(2)-350-25*3*(ii-1),50,20],...
        'Tag',['gapfill_EditPosY',num2str(ii)],...
        'callback',{@getpos,ii});    
end
% disable fields
set(findall(hFigGapFill,'tag','gapfill_EditPosX1'),'enable','inactive');
set(findall(hFigGapFill,'tag','gapfill_EditPosY2'),'enable','inactive');
% gap fill
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String','Gap Fill',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-550,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Pushbutton',...
    'String','Fill',...
    'unit','pixel',...
    'Tooltipstring','Start filling the gaps and/or bad pixels',...
    'Position',[20,figSize(2)-575,100,20],...
    'Tag','gapfill_PushbuttonFill',...
    'callback',@gapfill_PushbuttonFillFcn);
uicontrol('Parent',hFigGapFill,...
    'style','Pushbutton',...
    'String','Show Filled Image',...
    'unit','pixel',...
    'Position',[125,figSize(2)-575,100,20],...
    'Tag','gapfill_PushbuttonShowResult',...
    'callback',{@show,'imfdata',1,'Gap Fill - Filled Image'});
% data type
uicontrol('Parent',hFigGapFill,...
    'style','Text',...
    'Units','pixel',...
    'backgroundcolor',backgroundcolor,...
    'String',' Export - Select an export image format.',...
    'HorizontalAlignment','left',...
    'Position',[5,figSize(2)-600,figSize(1)-10,15]);
uicontrol('Parent',hFigGapFill,...
    'style','Popupmenu',...
    'units','pixel',...
    'String',{'logical','uint8','int8','uint16','int16','uint32','int32','single','uint64','int64','double'},...
    'value',8,...
    'HorizontalAlignment','left',...
    'Position',[20,figSize(2)-625,100,20],...
    'Tag','gapfill_PopupmenuImageType');
uicontrol('Parent',hFigGapFill,...
    'style','Pushbutton',...
    'String','To File',...
    'unit','pixel',...
    'Tooltipstring','Export to TIF/TIFF file.',...
    'Position',[125,figSize(2)-625,100,20],...
    'Tag','gapfill_PushbuttonExportToFile',...
    'callback',@gapfill_PushbuttonExportToFileFcn);
uicontrol('Parent',hFigGapFill,...
    'style','Pushbutton',...
    'String','To Workspace',...
    'unit','pixel',...
    'Tooltipstring','Export to Matlab workspace.',...
    'Position',[230,figSize(2)-625,100,20],...
    'Tag','gapfill_PushbuttonExportToWS',...
    'callback',@gapfill_PushbuttonExportToWSFcn);
% close
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Quit',...
    'unit','pixel',...
    'Position',[5,5,100,20],...
    'Tag','gapfill_PushbuttonQuit',...
    'callback','delete(gcbf)');
uicontrol('Parent',hFigGapFill,...
    'style','pushbutton',...
    'String','Close All',...
    'unit','pixel',...
    'Position',[110,5,100,20],...
    'Tag','gapfill_PushbuttonCloseAll',...
    'callback',@gapfill_PushbuttonCloseAllFcn);

% restore udata.path to pwd
udata = get(hFigGapFill,'UserData');
udata.path = pwd;
set(hFigGapFill,'UserData',udata);


function loaddlg(~,~,hEdit,dlgname,ii,file)
%hFigGapFill = findall(0,'Tag','gapfill_fig');
%udata = get(hFigGapFill,'UserData');
% oldpath = pwd;
% if ~isempty(udata.path), cd(udata.path); end
[filename,pathname] = uigetfile({'*.tif;*.tiff;';'*.cbf'},dlgname,file);
% cd(oldpath); 
if isequal(filename,0), return; end
f = fullfile(pathname,filename);
set(hEdit,'String',f);
feval(get(hEdit,'callback'),'','',ii);

function [path,file,data] = update_edit(hEdit,oldpath,oldfile,olddata)
f = get(hEdit,'string');
if isempty(f)
    path = oldpath;    
    file = '';
    data = [];
    return;
end
if exist(f,'file')==0, 
    errordlg('Invalid file name.','File Open Error','modal');
    set(hEdit,'string',oldfile);  
    path = oldpath;    
    file = oldfile;
    data = olddata;    
    return;
end
[pathstr, ~, ext] = fileparts(f);
if strcmpi(ext,'.tif') || ~strcmpi(ext,'.tiff')
    path = pathstr;
    file = f;    
    data = double(imread(f));    
elseif strcmpi(ext,'.cbf')
    path = pathstr;
    file = f;    
    tmp = cbfread(f);
    data = double(tmp.data');    
else
    errordlg('Invalid file format.','File Format Error','modal');
    set(hEdit,'string',oldfile);
    file = oldfile;
    path = oldpath;
    data = olddata;
    return;
end

function show(~,~,var,scaleflag,figurenamestr)
hFigGapFill = findall(0,'Tag','gapfill_fig');
udata = get(hFigGapFill,'UserData');
data = udata.(var);
if isempty(data), return; end;
figure('name',figurenamestr,'tag','gapfill_fig_data');
if scaleflag == 1
    tmp = data(~isnan(data));
    if islogical(data)
        cmap = [0,1];
    elseif strcmpi(var,'ff')
        cmap = [0.9,1.1];        
    else
        cmap = [0,mean(tmp(:))*10];
    end
    imagesc(data,cmap);
else
    data(data<=0) = NaN;
    tmp = data(~isnan(data));
    imagesc(log10(data),log10([min(tmp(:)),max(tmp(:))]));
end
axis image;
xlabel('x pixel'); ylabel('y pixel');

function gapfill_EditFFFcn(~,~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
hEditFF = findall(hFigGapFill,'tag','gapfill_EditFF');
udata = get(hFigGapFill,'UserData');
[udata.path,udata.fffile,udata.ff]= update_edit(hEditFF,udata.path,udata.fffile,udata.ff);
set(hFigGapFill,'UserData',udata); 

function gapfill_EditGapMaskFcn(~,~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
hEditGapMask = findall(hFigGapFill,'tag','gapfill_EditGapMask');
udata = get(hFigGapFill,'UserData');
[udata.path,udata.gapmaskfile,udata.gapmask]= ....
    update_edit(hEditGapMask,udata.path,udata.gapmaskfile,udata.gapmask);
udata.gapmask = logical(udata.gapmask);
set(hFigGapFill,'UserData',udata);

function gapfill_EditBadPixelMaskFcn(~,~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
hEditBadPixelMask = findall(hFigGapFill,'tag','gapfill_EditBadPixelMask');
udata = get(hFigGapFill,'UserData');
[udata.path,udata.badpixmaskfile,udata.badpixmask]= ....
    update_edit(hEditBadPixelMask,udata.path,udata.badpixmaskfile,udata.badpixmask);
udata.badpixmask = logical(udata.badpixmask);
set(hFigGapFill,'UserData',udata);

function gapfill_EditBaseFcn(~,~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
hEditBase = findall(hFigGapFill,'tag','gapfill_EditBase');
udata = get(hFigGapFill,'UserData');
[udata.path,udata.imbasefile,udata.imbasedata]= ....
    update_edit(hEditBase,udata.path,udata.imbasefile,udata.imbasedata);
set(hFigGapFill,'UserData',udata);

function gapfill_EditImageFcn(varargin)
hFigGapFill = findall(0,'Tag','gapfill_fig');
if nargin == 3
    ii = varargin{3};
else
    ii = get(gcbo,'UserData');
end
hEditImage = findall(hFigGapFill,'tag',['gapfill_EditImage',num2str(ii)]);
udata = get(hFigGapFill,'UserData');
[udata.path,udata.(['imfile',num2str(ii)]),udata.(['imdata',num2str(ii)])]= ....
             update_edit(hEditImage,udata.path,udata.(['imfile',num2str(ii)]),udata.(['imdata',num2str(ii)]));
set(hFigGapFill,'UserData',udata);

function getpos(~,~,ii)
hFigGapFill = findall(0,'Tag','gapfill_fig');
udata = get(hFigGapFill,'UserData');
pos = udata.(['pos',num2str(ii)]);
hEditPosX = findall(hFigGapFill,'tag',['gapfill_EditPosX',num2str(ii)]);
posX = round(str2double(get(hEditPosX,'String')));
if ~isnan(posX)
    pos(1) = posX;
end
set(hEditPosX,'String',num2str(pos(1)));
hEditPosY = findall(hFigGapFill,'tag',['gapfill_EditPosY',num2str(ii)]);
posY = round(str2double(get(hEditPosY,'String')));
if ~isnan(posY)
    pos(2) = posY;
end
set(hEditPosY,'String',num2str(pos(2)));
udata.(['pos',num2str(ii)]) = pos;
set(hFigGapFill,'UserData',udata);

function gapfill_PushbuttonFillFcn(~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
udata = get(hFigGapFill,'UserData');
% get base and offset images
imbase = udata.imbasedata;
imdata1 = udata.imdata1;
imdata2 = udata.imdata2;
imdata3 = udata.imdata3;
if isempty(imbase), clear_imfdata(hFigGapFill); return; end
if ((~isempty(imdata1))+ (~isempty(imdata2))+ (~isempty(imdata3))) ~=1
    clear_imfdata(hFigGapFill); 
    errordlg('Only one offset image is allowed.','Offse Image Error','modal');
    return; 
end
for ii=1:3
    eval(['tmp_data = imdata',num2str(ii),';']);
    if ~isempty(tmp_data) && ~isequal(size(tmp_data),size(imbase))
        clear_imfdata(hFigGapFill);
        errordlg(['Invalid size of offset image #',num2str(ii)],'Offse Image Error','modal');
        return;
    end
end
% get ff
ff = udata.ff;
if isempty(ff)
    ff = true(size(imbase));
elseif ~isequal(size(ff),size(imbase))
    clear_imfdata(hFigGapFill);
    errordlg('Invalid flat field image size.','Flat Field Error','modal');
    return;
end
ff(ff==0) = NaN; % mask ff (2013/02/03)
% get mask
gapmask = udata.gapmask;
badpixmask = udata.badpixmask;
if isempty(gapmask) && isempty(badpixmask)
    clear_imfdata(hFigGapFill);
    errordlg('Both gap mask and bad pixel mask are empty. At least one should exist.','Mask Error','modal');
    return;    
end
if isempty(gapmask)
    gapmask = true(size(imbase));
elseif ~isequal(size(gapmask),size(imbase))
    clear_imfdata(hFigGapFill);
    errordlg('Invalid gap mask size.','Mask Error','modal');
    return;     
end
if isempty(badpixmask)
    badpixmask = true(size(imbase));
elseif ~isequal(size(badpixmask),size(imbase))
    clear_imfdata(hFigGapFill);
    errordlg('Invalid bad pixel mask size.','Mask Error','modal');
    return;     
end
mask = gapmask & badpixmask;
% ff correction
imbase = imbase.*ff;
if ~isempty(imdata1), imdata1 = imdata1.*ff; end
if ~isempty(imdata2), imdata2 = imdata2.*ff; end
if ~isempty(imdata3), imdata3 = imdata3.*ff; end
% gap fill
imfdata = imbase;
if ~isempty(imdata1)
    [y0,x0] = find(~mask);    
    x1 = x0;
    y1 = y0+udata.pos1(2);
    ind = find(y1>size(imbase,1) | y1<1);
    x1(ind) = [];
    y1(ind) = [];
    x0(ind) = [];
    y0(ind) = [];
    imfdata(sub2ind(size(imbase),y0,x0)) = imdata1(sub2ind(size(imbase),y1,x1));
end
if ~isempty(imdata2)
    [y0,x0] = find(~mask);    
    x1 = x0-udata.pos2(1);
    y1 = y0;
    ind = find(x1>size(imbase,2) | x1<1);
    x1(ind) = [];
    y1(ind) = [];
    x0(ind) = [];
    y0(ind) = [];
    imfdata(sub2ind(size(imbase),y0,x0)) = imdata2(sub2ind(size(imbase),y1,x1));
end
if ~isempty(imdata3)
    [y0,x0] = find(~mask);    
    x1 = x0-udata.pos3(1);
    y1 = y0+udata.pos3(2);
    ind = find(x1>size(imbase,2) | x1<1 | y1>size(imbase,1) | y1<1);
    x1(ind) = [];
    y1(ind) = [];
    x0(ind) = [];
    y0(ind) = [];
    imfdata(sub2ind(size(imbase),y0,x0)) = imdata3(sub2ind(size(imbase),y1,x1));
end
imfdata(isnan(imfdata)) = -1;       % turn masked region to -1 (2013/02/03)
udata.imfdata = imfdata;
set(hFigGapFill,'UserData',udata);
show([],[],'imfdata',1,'Gap Fill - Filled Image');

function gapfill_PushbuttonExportToFileFcn(~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
udata = get(hFigGapFill,'UserData');
hPopupmenuImageType = findall(hFigGapFill,'tag','gapfill_PopupmenuImageType');
type_str = get(hPopupmenuImageType,'string');
type_value = get(hPopupmenuImageType,'value');
imfdata = udata.imfdata;
if isempty(imfdata) || isempty(udata.imbasedata), return; end
[~,basefilename,~] = fileparts(udata.imbasefile);
[filename,filepath] = uiputfile(...
    {'*.tif','TIFF files (*.tif)'},...
    'Export Gap Filled Image to File',...
    fullfile(udata.path,[basefilename,'_GapFilled.tif']));
if isequal(filename,0), return; end
f = fullfile(filepath,filename);
[~,~,ext] = fileparts(f);
if ~strcmpi(ext,'.tif') && ~strcmpi(ext,'.tiff')
    f = [f,'.tif'];
end
imwrite2tif(imfdata,[],f,type_str{type_value});
return;

function gapfill_PushbuttonExportToWSFcn(~,~)
hFigGapFill = findall(0,'Tag','gapfill_fig');
udata = get(hFigGapFill,'UserData');
if isempty(udata.imfdata), return; end
[~,basefilename,~] = fileparts(udata.imbasefile);
assignin('base',assignin_base_name_check([basefilename,'_GapFilled']),udata.imfdata);

function var_name = assignin_base_name_check(var_name)
var_name(strfind(var_name,'-')) = '_';

function clear_imfdata(hFigGapFill)
udata = get(hFigGapFill,'UserData');
udata.imfdata = [];
set(hFigGapFill,'UserData',udata);

function gapfill_PushbuttonCloseAllFcn(~,~)
hfigs = findall(0,'type','figure');
tags = get(hfigs,'tag');
if ~iscell(tags), tags = {tags}; end
for ii=1:length(hfigs)
    if ~isempty(strfind(tags{ii},'gapfill_fig_data')), delete(hfigs(ii)); end
end